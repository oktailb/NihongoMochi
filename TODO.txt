Objectif:
La meilleure appli d apprentissage du japonais qui soit


Features:
 - Grammar section with typical JLTP exercises
   - fill exercices database and lessons -> Sofia
 - Prévoir l'intégration "Social" (comparaison de progression) pour plus tard.
   - reussir la connexion au google play !
 - Du son ! Du bruit ! des effets ! [TODO: Interface AudioPlayer expect/actual]

Games:
  - [X] memorize: hidden card pairs -> retrieve couples, different modes -> kanji/kanji kanji/meaning kanji/reading reading/meaning
  - [X] Simon : enforce kanji remembering by sequence
  - [X] Taquin : redo the basic gojuon table hiragana/katakana
  - [/] Tetris/Candycrush like (Kana Drop) : achieve words from selected level in Kana to Smake blocks disappear [SOMEWHAT DONE, maybe more to do]
  - [ ] Crosswords (Mochi-Cross) : crossword generator using JLPT vocabulary
  - [ ] Particle Defender : shooter grammatical pour automatiser le choix des particules (wa, ga, ni, o...)
  - [ ] Radical Forge : puzzle de construction de Kanji à partir de leurs radicaux
  - [ ] Shiritori Zen : jeu de chaîne de mots traditionnel japonais contre l'IA
  - [ ] Shadow Kanji : identification de Kanjis par leur silhouette ou tracé flou

KMP & Architecture Refactoring (Technical Debt):
 - [X] Refactor ScoreManager : transformer l'object Singleton en class injectée via Koin (supprimer le .init())
 - [X] ResourceUtils : le mapping manuel Res.string est fragile. Remplacé par une HashMap O(1).
 - [ ] Audio : Créer une interface AudioPlayer dans commonMain pour gérer les sons/musiques de manière agnostique.
 - [ ] Abstraction Services : S'assurer que CloudSaveService et HandwritingRecognizer ont des implémentations par défaut (No-op) pour faciliter le portage iOS/Desktop.
 - [ ] Clean API : Isoler ResourceUtils pour que les ViewModels ne dépendent pas directement de l'objet Res de Compose.

Optimisations (Mémoire/CPU):
 - [ ] Persistence des données : ScoreManager sérialise toute la base en un seul JSON string. Risque de pic mémoire/CPU. Passer à SQLDelight pour une gestion granulaire.
 - [ ] Kana Drop : Minimiser les allocations d'objets dans applyGravity (évitement de .map { .map { ... } } à chaque mouvement).
 - [X] Lookup de ressources : Remplacer le "when" massif de ResourceUtils par une HashMap initialisée une seule fois (O(1) lookup).
 - [X] Ressources Graphiques : Convertir les PNG (assets/screenshots) en WebP pour réduire le poids de l'APK et l'empreinte mémoire.
 - [X] Game Init : Mettre en cache les kanaPools par niveau JLPT au lieu de les recalculer à chaque lancement de jeu.
 - [ ] Recomposition UI : S'assurer que les ticks du timer dans KanaDrop n'entraînent pas une recomposition complète de la grille (stabilité des modèles).
